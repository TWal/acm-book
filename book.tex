\documentclass[landscape,a4paper,twocolumn,10pt]{report}

% \usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage{DejaVuSansMono}
\usepackage[usenames,dvipsnames]{color}
\usepackage{amsmath,amssymb,listings,array,fancyhdr,lastpage}
\usepackage[landscape,pdftex,top=1.5cm,bottom=0.5cm,left=0.475cm,right=0.475cm]{geometry}

\definecolor{dkgreen}{rgb}{0,0.6,0}
\lstset{
    language=C++,
    morekeywords={lli, llu, pii, piii, vi, vii, viii, vvi, vvii, vviii, pt, FOR, FORU, FORD},
    basicstyle=\ttfamily,
    keywordstyle=\color{blue}\ttfamily,
    stringstyle=\color{red}\ttfamily,
    commentstyle=\color{dkgreen}\ttfamily,
    morecomment=[l][\color{magenta}]{\#}
}

\setlength{\columnsep}{15pt}
\setlength{\columnseprule}{1pt}
\setlength{\headsep}{0.1cm}
\setlength{\footskip}{0cm}

\pagestyle{fancy}
\lhead{\'Ecole Normale Sup\'erieure ULM}
\chead{\textit{\small{}ENS Ulm 3}}
\rhead{\thepage{} of~\pageref{LastPage}}
\lfoot{}
\cfoot{}
\rfoot{}
\renewcommand{\headrulewidth}{0.1pt}
\renewcommand{\footrulewidth}{0pt}

\renewcommand{\line}{\noindent\rule{\linewidth}{1pt}}
\newcommand{\algosection}[1]{\line \subsection*{#1}}
\newcommand{\algorithm}[1]{\line \subsubsection*{#1}}

\begin{document}

\footnotesize

\noindent
Pre-contest: page \pageref{precontest} \\
Math: page \pageref{math} \\
String processing: page \pageref{string} \\
Data structures: page \pageref{datastruct} \\
Flows: page \pageref{flows} \\
Graphs: page \pageref{graphs} \\
Trees: page \pageref{trees} \\
Misc: page \pageref{misc}

\noindent
Notation: \verb#v[i:j]# = \verb#[v[i], v[i+1], ..., v[j-1]]# (like Python)

\algosection{Pre-contest}
\label{precontest}

\algorithm{.vimrc}
\lstinputlisting[language={}]{src/precontest/vimrc}

\algorithm{.bashrc}
\lstinputlisting[language=bash]{src/precontest/bashrc}

\algorithm{comp.sh}
\lstinputlisting[language=bash]{src/precontest/comp.sh}

\algorithm{template.cpp}
\lstinputlisting{src/precontest/template.cpp}

\algosection{Math}
\label{math}

\algorithm{Extended GCD - $O(\log(\min(a, b)))$}
\lstinputlisting{src/math/egcd.cpp}

\algorithm{Inverse of $a$ modulo $m$ when $\operatorname{gcd}(a, m) = 1$ - $O(\log(\min(a, m)))$}
\lstinputlisting{src/math/invmod.cpp}

\algorithm{Inverses modulo $p$ of $\{1, \dots, N\}$ - $O(N)$}
\lstinputlisting{src/math/invmod_range.cpp}

\algorithm{Field $\mathbb F_p$ or group $\mathbb Z/n\mathbb Z$}
\lstinputlisting{src/math/Fp.cpp}

\algorithm{FFT / NTT / Polynomial multiplication - $O(n \log n)$}
\lstinputlisting{src/math/fft.cpp}

\algorithm{Utility to find NTT parameters}
\lstinputlisting[language=python]{src/math/findNTTParams.py}

\algorithm{Gauss - Solve linear system - Calculate matrix rank - $O(n^3)$}
\lstinputlisting{src/math/gauss.cpp}

\algorithm{Gauss in $\mathbb Z/2\mathbb Z$ - $O(n^3)$ (really good constant)}
\lstinputlisting{src/math/gauss_z2z.cpp}

\algorithm{Walsh-Hadamard transform - xor convolution - $O(n \log n)$}
\lstinputlisting{src/math/walsh_hadamard.cpp}

\algorithm{Subset sum transform - or convolution - $O(n \log n)$}
\lstinputlisting{src/math/subset_sum.cpp}

\algorithm{Modular operations on $\texttt{llu}$ (without overflow)}
\lstinputlisting{src/math/opmod.cpp}

\algorithm{Pollard's rho (number factorization) - $O(n^{\frac{1}{4}})$ in expectation}
\lstinputlisting{src/math/pollard_rho.cpp}

\algorithm{Miller-rabin (primality test) - $O(\log(n))$}
\lstinputlisting{src/math/miller_rabin.cpp}

\algorithm{Generate primes $< N$ - $O(N \log N)$}
\lstinputlisting{src/math/gen_primes.cpp}

\algorithm{Factorize numbers in $\{L, \dots, R\}$ - $O(\sqrt{R} + (R-L) \log(R))$}
\lstinputlisting{src/math/factorize_range.cpp}

\algorithm{Polynomial euclidian division - $O(|Q|(|P|-|Q|))$}
\lstinputlisting{src/math/polynom_euclid.cpp}

\algorithm{$n$th term of linear reccurence of order $k$ - $O(k^2 \log(n))$}
\lstinputlisting{src/math/linear_reccurence.cpp}

\algosection{String processing}
\label{string}

\algorithm{KMP - $O(m+n)$}
\lstinputlisting{src/string/kmp.cpp}

\algorithm{Z function - $O(n)$}
\lstinputlisting{src/string/zfunc.cpp}

\algorithm{Aho-Corasick - linear}
\lstinputlisting{src/string/ahocorasick.cpp}

\algorithm{Suffix automaton - $O(n \Sigma)$}
\lstinputlisting{src/string/suffixautomaton.cpp}

\algorithm{Suffix array \& LCP - $O(n \log(n)^2)$}
\lstinputlisting{src/string/suffixarray.cpp}

\algorithm{Suffix array \& LCP using Suffix Automaton - $O(n \Sigma)$}
\lstinputlisting{src/string/suffixarray_linear.cpp}

\algorithm{Manacher - find all palindromes - $O(n)$}
\lstinputlisting{src/string/manacher.cpp}

\algorithm{Palindromic tree - $O(n)$}
\lstinputlisting{src/string/palindromic_tree.cpp}

\algosection{Data structures}
\label{datastruct}

\algorithm{Union-find - amortized $O(\log(n))$}
\lstinputlisting{src/datastruct/unionfind.cpp}

\algorithm{Fenwick tree - $O(\log(n))$ add / get}
\lstinputlisting{src/datastruct/fenwick.cpp}

\algorithm{Fenwick tree with range update - $O(\log(n))$ add / addRange / get}
\lstinputlisting{src/datastruct/fenwick_range.cpp}

\algorithm{Segment tree - $O(\log(n))$ modify / inc / query}
\lstinputlisting{src/datastruct/segtree.cpp}

\algorithm{Lazy Segment tree - $O(\log(n))$ range add / query}
\lstinputlisting{src/datastruct/lazysegtree.cpp}

\algorithm{Treap - Augmentable binary search tree - $O(\log(n))$ insert / split / merge}
\lstinputlisting{src/datastruct/treap.cpp}

%\algorithm{Generic segment tree - Example of treap augmentation - $O(\log(n))$ insert / query / add}
%\lstinputlisting{src/datastruct/treap_gensegtree.cpp}

\algorithm{RMQ - $O(n \log n)$ initialization - $O(1)$ query}
\lstinputlisting{src/datastruct/rmq.cpp}

\algorithm{Wavelet Tree - build $O(n \log \Sigma)$ - activate/kth/rank/rankrange/swap $O(\log \Sigma)$ or $O(\log(\Sigma) \log(n))$}
\lstinputlisting{src/datastruct/wavelettree.cpp}

\algorithm{LogVector / Implicit Cartesian Tree - everything in $O(\log n)$}
\lstinputlisting{src/datastruct/logvector.cpp}

\algosection{Flows}
\label{flows}

\algorithm{Common graph structure}
\lstinputlisting{src/flow/graph.cpp}

\algorithm{Dinic - $O(V^2 E)$}
\lstinputlisting{src/flow/dinic.cpp}

\algorithm{Capacity Scaling - $O(E^2 \log(C))$ ($C$ = capacitÃ© max)}
\lstinputlisting{src/flow/cap_scaling.cpp}



\algosection{Graphs}
\label{graphs}

\algorithm{Strongly connected component Tarjan - $O(V + E)$}
\lstinputlisting{src/graph/scc_tarjan.cpp}

%\algorithm{Strongly connected component Kosaraju - $O(V + E)$}
%\lstinputlisting{src/graph/scc_kosaraju.cpp}

\algorithm{Articulation points / N\oe uds essentiels - $O(V + E)$}
\lstinputlisting{src/graph/articulation.cpp}

\algorithm{Bridges / Arcs essentiels - $O(V + E)$}
\lstinputlisting{src/graph/bridges.cpp}

\algorithm{Dominator Tree}
\lstinputlisting{src/graph/dominator_tree.cpp}

\algosection{Trees}
\label{trees}

\algorithm{LCA - $O(n \log n)$ preprocessing, $O(1)$ query}
\lstinputlisting{src/tree/lca.cpp}

\algorithm{Dynamic LCA - $O(\log n)$ add, $O(\log n)$ query}
\lstinputlisting{src/tree/lca_dyn.cpp}

\algorithm{Heavy-Light decomposition - $O(n)$ build, $O(\log n)$ LCA}
\lstinputlisting{src/tree/heavy_light.cpp}


\algosection{Misc}
\label{misc}

\algorithm{LIS (Longest Increasing Subsequence) - $O(n \log n)$}
\lstinputlisting{src/misc/lis_full.cpp}

\algorithm{Size of LIS - $O(n \log n)$}
\lstinputlisting{src/misc/lis_short.cpp}

\end{document}

\end{document}
